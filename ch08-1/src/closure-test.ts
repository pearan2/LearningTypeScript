/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   closure-test.ts                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: honlee <honlee@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/05/31 12:26:07 by honlee            #+#    #+#             */
/*   Updated: 2021/05/31 14:43:23 by honlee           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

// 고차함수의 몸통에서 선언되는 변수들은 클로저(closure)라는 유효 범위를 가집니다.
// 클로저는 '지속되는 유효범위(persistence scope)'를 의미합니다.
// 다음 코드에서 return x + y 부분은 add 함수가 반환하는 함수의 반환문인데,
// 이 함수는 자신의 바깥쪽 유효범위(outerscope)에 있는 변수 x를 참조하고 있습니다.

function add(x:number): (arg0 : number) => number {      // 바깥쪽 유효 범위 시작
	return function(y: number): number {				 // 안쪽 유효 범위 시작
		return (x + y)									 // 클로저
	}													 // 안쪽 유효범위 끝
}														 // 바깥쪽 유효 범위 끝

// 그런데 add 가 반환하는 함수의 내부범위(inner scope) 만 놓고 볼때, x 는 이해할수 없는 변수입니다.
// 이처럼 범위 안에서는 그 의미를 알 수 없는 변수를 자유변수(free variable)라고 합니다.
// 타입스크립트는 이처럼 자유변수가 있으면 그 변수의 바깥쪽 유효범위에서 자유변수의 의미를 찾는데,
// 바깥쪽 유효 범위에서 x의 의미 (x : number) 를 알수 있으므로 코드를 정상적으로 컴파일 합니다.
// 클로저를 지속되는 유효범위라고 하는 이유는 다음처럼 add 함수를 호출하더라도 변수 x가 메모리에서 해제 되지 않기 때문입니다.

const add1 = add(1) // 변수 x 메모리 유지

// 자유변수 x는 다음코드가 실행되어야 비로소 메모리가 해제 됩니다.

const result = add1(2)  // result에 3을 저장후 변수 x 메모리 해제

// 이처럼 고차함수가 부분함수가 아닌 '값'을 발생해야 비로소 자유변수의 메모리가 해제되는 유효범위를 '클로저' 라고 합니다.
// 어떤 프로그래밍언어는 클로저와 고차함수를 한꺼번에 클로저라고 표현하기도 합니다.

// 클로저는 메모리가 해제되지 않고 프로그램이 끝날때까지 지속 될 수도 있습니다. 다음 makeName 함수는 () => string 타입의 함수를 반환하는 2차 고차함수입니다.

const makeNames = ():() => string => { // 바깥쪽 유효범위
	const names = ['jack', 'jane', 'smith']
	let index = 0
	return (): string => {
		if (index == names.length)
			index = 0
		return names[index++]
	}
}

const makeName: () => string = makeNames() // makeName 은 () => string 타입이다.
console.log(
	[1, 2, 3, 4, 5, 6].map(n => makeName())
)

//makeName 함수를 사용하는한, makeNames 함수에 할당된 클로저는 해제되지 않는다.